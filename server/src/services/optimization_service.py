"""
Resume Optimization Service

This module handles AI-powered resume optimization while preserving the original structure.
Supports both PDF and DOCX formats using different strategies:
- PDF: Search and replace text while preserving original formatting
- DOCX: Run-level editing to preserve formatting
"""

import os
import json
import fitz  # PyMuPDF
from io import BytesIO
from typing import Dict, List, Optional
from pathlib import Path

from openai import OpenAI
from docx import Document


async def optimize_resume_pdf(
    pdf_buffer: bytes,
    selected_keywords: List[str],
    job_data: Dict,
    resume_text: str
) -> bytes:
    """
    Optimize PDF resume using text search and replace approach.
    Preserves original formatting by finding text and replacing in-place.
    """
    try:
        # Step 1: Extract text structure from PDF
        doc = fitz.open(stream=pdf_buffer, filetype="pdf")

        # Build content structure for AI
        content_structure = []
        for page_num in range(len(doc)):
            page = doc[page_num]
            blocks = page.get_text("dict")["blocks"]

            for block in blocks:
                if block.get("type") == 0:  # Text block
                    for line in block.get("lines", []):
                        line_text = ""
                        line_info = {
                            "page": page_num,
                            "bbox": line.get("bbox"),
                            "spans": []
                        }

                        for span in line.get("spans", []):
                            text = span.get("text", "")
                            line_text += text
                            line_info["spans"].append({
                                "text": text,
                                "font": span.get("font", "helv"),
                                "size": span.get("size", 11),
                                "color": span.get("color", 0),
                                "origin": span.get("origin"),
                                "bbox": span.get("bbox")
                            })

                        if line_text.strip() and len(line_text.strip()) > 5:
                            line_info["text"] = line_text.strip()
                            content_structure.append(line_info)

        doc.close()

        # Step 2: Create edit plan using AI
        edit_plan = await create_optimization_plan(
            content_structure,
            selected_keywords,
            job_data,
            resume_text
        )

        if not edit_plan.get("edits"):
            print("No edits generated by AI")
            return pdf_buffer

        # Step 3: Apply edits using proper text replacement
        doc = fitz.open(stream=pdf_buffer, filetype="pdf")

        edits_made = 0
        for edit in edit_plan.get("edits", []):
            try:
                segment_idx = edit.get("segment_index", -1)
                if segment_idx < 0 or segment_idx >= len(content_structure):
                    continue

                segment = content_structure[segment_idx]
                page_num = segment["page"]
                original_text = edit.get("original", segment["text"])
                optimized_text = edit.get("optimized", "")

                if not optimized_text or original_text == optimized_text:
                    continue

                page = doc[page_num]

                # Search for the original text
                text_instances = page.search_for(original_text, quads=True)

                if not text_instances:
                    # Try searching for partial text
                    words = original_text.split()
                    if len(words) > 2:
                        partial = " ".join(words[:3])
                        text_instances = page.search_for(partial, quads=True)

                if text_instances:
                    # Get the first instance
                    quad = text_instances[0]
                    rect = quad.rect

                    # Get font info from the segment
                    font_size = 11
                    font_color = (0, 0, 0)
                    if segment.get("spans"):
                        first_span = segment["spans"][0]
                        font_size = first_span.get("size", 11)
                        color_int = first_span.get("color", 0)
                        if isinstance(color_int, int):
                            r = ((color_int >> 16) & 255) / 255
                            g = ((color_int >> 8) & 255) / 255
                            b = (color_int & 255) / 255
                            font_color = (r, g, b)

                    # Method 1: Use redaction to properly remove and replace text
                    # Add redaction annotation
                    annot = page.add_redact_annot(rect)
                    annot.set_info(content=optimized_text)

                    # Apply redaction with replacement text
                    page.apply_redactions(
                        images=fitz.PDF_REDACT_IMAGE_NONE,
                        graphics=fitz.PDF_REDACT_LINE_ART_NONE,
                        text=fitz.PDF_REDACT_TEXT_REMOVE
                    )

                    # Calculate text position - use original baseline
                    # The y-coordinate should be at the baseline of the text
                    text_y = rect.y1 - 2  # Slight adjustment for baseline
                    text_x = rect.x0

                    # Insert the optimized text at the same position
                    text_point = fitz.Point(text_x, text_y)

                    # Insert text with matching formatting
                    rc = page.insert_text(
                        text_point,
                        optimized_text,
                        fontname="helv",
                        fontsize=font_size,
                        color=font_color,
                        render_mode=0  # Fill text
                    )

                    if rc > 0:
                        edits_made += 1
                        print(f"✓ Replaced [{segment_idx}]: '{original_text[:40]}...' → '{optimized_text[:40]}...'")
                    else:
                        print(f"✗ Failed to insert text for segment {segment_idx}")
                else:
                    print(f"✗ Could not find text for segment {segment_idx}: '{original_text[:40]}...'")

            except Exception as e:
                print(f"Error applying edit {segment_idx}: {e}")
                continue

        print(f"\n=== Total edits applied: {edits_made} ===")

        # Save the modified PDF
        pdf_bytes = doc.tobytes(garbage=4, deflate=True)
        doc.close()

        return pdf_bytes

    except Exception as e:
        print(f"PDF optimization failed: {str(e)}")
        import traceback
        traceback.print_exc()
        raise Exception(f"Failed to optimize PDF resume: {str(e)}")


async def optimize_resume_docx(
    docx_buffer: bytes,
    selected_keywords: List[str],
    job_data: Dict,
    resume_text: str
) -> bytes:
    """
    Optimize DOCX resume using run-level editing to preserve formatting.
    """
    try:
        doc = Document(BytesIO(docx_buffer))

        # Extract structured segments
        segments = []
        for para_idx, paragraph in enumerate(doc.paragraphs):
            if paragraph.text.strip():
                segments.append({
                    "type": "paragraph",
                    "index": para_idx,
                    "text": paragraph.text,
                })

        # Create AI optimization plan
        edit_plan = await create_optimization_plan(
            segments,
            selected_keywords,
            job_data,
            resume_text
        )

        # Apply edits
        apply_docx_edits(doc, edit_plan)

        # Save to bytes
        output = BytesIO()
        doc.save(output)
        output.seek(0)

        return output.read()

    except Exception as e:
        print(f"DOCX optimization failed: {str(e)}")
        raise Exception(f"Failed to optimize DOCX resume: {str(e)}")


async def create_optimization_plan(
    content_structure: List[Dict],
    selected_keywords: List[str],
    job_data: Dict,
    resume_text: str
) -> Dict:
    """
    Use AI to create a structured edit plan for resume optimization.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise Exception("OpenAI API key not configured")

    client = OpenAI(api_key=api_key)

    # Build segment list for AI - only include substantial text
    segments_for_ai = []
    for i, seg in enumerate(content_structure[:60]):
        text = seg.get('text', '')
        if len(text) > 15:  # Only include meaningful segments
            segments_for_ai.append(f"[{i}] {text}")

    segments_text = "\n".join(segments_for_ai[:40])
    keywords_text = ", ".join(selected_keywords[:12])

    prompt = f"""You are optimizing a resume for ATS systems. Incorporate the keywords naturally into existing text.

JOB: {job_data.get('title', 'N/A')} at {job_data.get('company', 'N/A')}

KEYWORDS TO ADD: {keywords_text}

RESUME SEGMENTS:
{segments_text}

CRITICAL RULES:
1. ONLY modify bullet points or descriptions - NOT headers, names, dates, or contact info
2. Keep optimized text SAME LENGTH or slightly shorter than original
3. Preserve all numbers, percentages, and achievements exactly
4. Add keywords naturally - don't force them
5. Maximum 8 edits
6. The "original" field must EXACTLY match the segment text

Return ONLY valid JSON:
{{
  "edits": [
    {{
      "segment_index": 5,
      "original": "exact text from segment",
      "optimized": "text with keyword integrated naturally",
      "keywords_added": ["keyword1"]
    }}
  ],
  "summary": "Brief description of changes"
}}"""

    try:
        response = client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[
                {
                    "role": "system",
                    "content": "You are an expert ATS resume optimizer. Return only valid JSON. Make subtle, natural edits that maintain text length."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.2,
            max_tokens=2000
        )

        response_text = response.choices[0].message.content.strip()

        # Clean markdown formatting
        if "```json" in response_text:
            response_text = response_text.split("```json")[1].split("```")[0]
        elif "```" in response_text:
            parts = response_text.split("```")
            if len(parts) >= 2:
                response_text = parts[1]

        response_text = response_text.strip()

        edit_plan = json.loads(response_text)
        print(f"AI generated {len(edit_plan.get('edits', []))} optimization edits")

        # Log the edits for debugging
        for edit in edit_plan.get('edits', []):
            print(f"  Edit [{edit.get('segment_index')}]: +{edit.get('keywords_added', [])}")

        return edit_plan

    except json.JSONDecodeError as e:
        print(f"JSON parse error: {e}")
        print(f"Raw response: {response_text[:500] if 'response_text' in dir() else 'N/A'}")
        return {"edits": [], "summary": "Failed to parse AI response"}
    except Exception as e:
        print(f"AI optimization failed: {e}")
        return {"edits": [], "summary": f"Error: {str(e)}"}


def apply_docx_edits(doc: Document, edit_plan: Dict) -> None:
    """Apply optimizations to DOCX document."""
    edits_map = {
        edit["segment_index"]: edit["optimized"]
        for edit in edit_plan.get("edits", [])
    }

    para_idx = 0
    for paragraph in doc.paragraphs:
        if paragraph.text.strip() and para_idx in edits_map:
            new_text = edits_map[para_idx]

            if len(paragraph.runs) > 0:
                paragraph.runs[0].text = new_text
                for run in paragraph.runs[1:]:
                    run.text = ""
            else:
                paragraph.text = new_text

        if paragraph.text.strip():
            para_idx += 1

